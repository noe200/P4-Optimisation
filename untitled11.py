# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S5qvGCEfHxL11KwlT8hEAT6pwDrHsjBZ
"""

from google.colab import files
uploaded = files.upload()

!ls

import numpy as np
import pandas as pd
from google.colab import files

# Fonction pour charger le fichier
def load_data(file_path):
    """
    Charger les données du problème de transport depuis un fichier CSV.
    Le fichier doit contenir l'offre, la demande, et la matrice des coûts.
    """
    # Lire le fichier CSV avec un séparateur de type point-virgule
    data = pd.read_csv(file_path, delimiter=";", header=None)

    # Extraire la demande (première ligne)
    demand = data.iloc[0, 1:].values.astype(float)

    # Extraire l'offre (première colonne)
    supply = data.iloc[1:, 0].values.astype(float)

    # Extraire la matrice des coûts (reste du tableau)
    cost = data.iloc[1:, 1:].values.astype(float)

    return supply, demand, cost

# Algorithmes pour trouver la solution initiale
def northwest_corner_rule(supply, demand):
    m, n = len(supply), len(demand)
    allocation = np.zeros((m, n))
    i, j = 0, 0

    while i < m and j < n:
        allocation[i, j] = min(supply[i], demand[j])
        if supply[i] < demand[j]:
            demand[j] -= supply[i]
            i += 1
        else:
            supply[i] -= demand[j]
            j += 1
    return allocation

def minimum_cost_method(supply, demand, cost):
    allocation = np.zeros_like(cost)
    cost_copy = cost.copy()
    supply = supply.copy()
    demand = demand.copy()

    while np.sum(supply) > 0 and np.sum(demand) > 0:  # Continue tant qu'il y a encore de l'offre et de la demande
        min_cost_idx = np.unravel_index(np.argmin(cost_copy, axis=None), cost_copy.shape)
        i, j = min_cost_idx

        # Allocation de la quantité minimale entre l'offre et la demande
        allocate = min(supply[i], demand[j])
        allocation[i, j] = allocate
        supply[i] -= allocate
        demand[j] -= allocate

        # Mettre à jour les coûts pour exclure les lignes et colonnes où l'offre ou la demande est épuisée
        if supply[i] == 0:
            cost_copy[i, :] = np.inf  # Marque toute la ligne comme infinie
        if demand[j] == 0:
            cost_copy[:, j] = np.inf  # Marque toute la colonne comme infinie

    return allocation

def minimum_row_cost_method(supply, demand, cost):
    allocation = np.zeros_like(cost)
    supply = supply.copy()
    demand = demand.copy()

    for i in range(len(supply)):
        row_costs = cost[i, :]
        for j in np.argsort(row_costs):  # Tri des coûts de la ligne par ordre croissant
            if supply[i] == 0:
                break
            allocate = min(supply[i], demand[j])
            allocation[i, j] = allocate
            supply[i] -= allocate
            demand[j] -= allocate
    return allocation

def vogels_method(supply, demand, cost):
    allocation = np.zeros_like(cost)
    supply = supply.copy()
    demand = demand.copy()
    cost = cost.copy()

    while np.sum(allocation) < np.sum(supply):
        # Calcul des différences de pénalité pour chaque ligne
        row_diff = np.apply_along_axis(
            lambda row: np.partition(row, 1)[1] - row[0] if len(row) > 1 else 0,
            axis=1,
            arr=cost
        )
        # Calcul des différences de pénalité pour chaque colonne
        col_diff = np.apply_along_axis(
            lambda col: np.partition(col, 1)[1] - col[0] if len(col) > 1 else 0,
            axis=0,
            arr=cost
        )

        # Calcul des pénalités maximales
        penalties = np.concatenate((row_diff, col_diff))
        max_penalty_idx = np.argmax(penalties)

        if max_penalty_idx < len(supply):
            i = max_penalty_idx
            j = np.argmin(cost[i, :])
        else:
            j = max_penalty_idx - len(supply)
            i = np.argmin(cost[:, j])

        allocate = min(supply[i], demand[j])
        allocation[i, j] = allocate
        supply[i] -= allocate
        demand[j] -= allocate

        # Mettre à jour les coûts en marquant les lignes et colonnes épuisées
        if supply[i] == 0:
            cost[i, :] = np.inf
        if demand[j] == 0:
            cost[:, j] = np.inf

    return allocation

# Chargement et exécution
if __name__ == "__main__":
    # Téléchargez le fichier CSV
    print("Téléchargez le fichier CSV contenant les données du problème de transport.")
    uploaded = files.upload()

    # Nom du fichier
    file_path = list(uploaded.keys())[0]

    # Chargement des données
    supply, demand, cost = load_data(file_path)

    print("Supply:", supply)
    print("Demand:", demand)
    print("Cost Matrix:")
    print(cost)

    # Northwest Corner Rule
    nw_allocation = northwest_corner_rule(supply.copy(), demand.copy())
    print("\nNorthwest Corner Rule Allocation:")
    print(nw_allocation)

    # Minimum Cost Method
    min_cost_allocation = minimum_cost_method(supply.copy(), demand.copy(), cost)
    print("\nMinimum Cost Method Allocation:")
    print(min_cost_allocation)

    # Minimum Row Cost Method
    min_row_cost_allocation = minimum_row_cost_method(supply.copy(), demand.copy(), cost)
    print("\nMinimum Row Cost Method Allocation:")
    print(min_row_cost_allocation)

    # Vogel's Method
    vogels_allocation = vogels_method(supply.copy(), demand.copy(), cost)
    print("\nVogel's Approximation Method Allocation:")
    print(vogels_allocation)